"use strict";
/*
    TyronZIL-js: Decentralized identity client for the Zilliqa blockchain platform
    Copyright (C) 2020 Julio Cesar Cabrapan Duarte

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const zcrypto = __importStar(require("@zilliqa-js/crypto"));
const did_create_1 = __importDefault(require("../lib/decentralized-identity/did-operations/did-create"));
const did_update_1 = __importDefault(require("../lib/decentralized-identity/did-operations/did-update"));
const did_recover_1 = __importDefault(require("../lib/decentralized-identity/did-operations/did-recover"));
const did_deactivate_1 = __importDefault(require("../lib/decentralized-identity/did-operations/did-deactivate"));
const util_1 = __importDefault(require("./util"));
const tyronzil_1 = __importStar(require("../lib/blockchain/tyronzil"));
const did_scheme_1 = __importStar(require("../lib/decentralized-identity/tyronZIL-schemes/did-scheme"));
const did_state_1 = __importDefault(require("../lib/decentralized-identity/did-operations/did-resolve/did-state"));
const did_document_1 = __importStar(require("../lib/decentralized-identity/did-operations/did-resolve/did-document"));
const document_model_1 = require("../lib/decentralized-identity/protocols/models/document-model");
const ErrorCode_1 = __importDefault(require("../lib/decentralized-identity/util/ErrorCode"));
const log_colors_1 = __importDefault(require("./log-colors"));
const readline = __importStar(require("readline-sync"));
const resolver_1 = __importDefault(require("../lib/decentralized-identity/did-operations/did-resolve/resolver"));
const ErrorCode_2 = __importDefault(require("../lib/decentralized-identity/util/ErrorCode"));
/** Handles the command-line interface Tyron DID operations */
class TyronCLI {
    /** Gets network choice from the user */
    static network() {
        const network = readline.question(log_colors_1.default.green(`On which Zilliqa network would you like to operate, mainnet(m), testnet(t) or isolated server(i)?`) + ` - [m/t/i] - Defaults to testnet - ` + log_colors_1.default.lightBlue(`Your answer: `));
        // Both default to testnet
        let NETWORK;
        let INIT_TYRON; //address of the init.tyron smart contract
        switch (network.toLowerCase()) {
            case 'm':
                NETWORK = did_scheme_1.NetworkNamespace.Mainnet;
                INIT_TYRON = tyronzil_1.InitTyron.Mainnet;
                break;
            case 'i':
                NETWORK = did_scheme_1.NetworkNamespace.Isolated;
                INIT_TYRON = tyronzil_1.InitTyron.Isolated;
                break;
            default:
                // Defaults to testnet
                NETWORK = did_scheme_1.NetworkNamespace.Testnet;
                INIT_TYRON = tyronzil_1.InitTyron.Testnet;
                break;
        }
        return {
            network: NETWORK,
            initTyron: INIT_TYRON
        };
    }
    /***            ****            ***/
    /** Handles the `Tyron  DID-Create` operation */
    static handleCreate() {
        return __awaiter(this, void 0, void 0, function* () {
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            console.log(log_colors_1.default.brightGreen(`The user is the contract owner of their Tyron DID smart contract (DIDC)`));
            const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 50,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            console.log(log_colors_1.default.brightGreen(`Initializing...`));
            yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit)
                .then((init) => __awaiter(this, void 0, void 0, function* () {
                // Adds verification-method inputs & services:
                const KEY_INPUT = yield util_1.default.InputKeys();
                const SERVICES = yield util_1.default.services();
                const CLI_INPUT = {
                    network: NETWORK,
                    publicKeyInput: KEY_INPUT,
                    services: SERVICES,
                    userPrivateKey: contractOwner_privateKey
                };
                /** Executes the `Tyron DID-Create` operation */
                const OPERATION = yield did_create_1.default.execute(CLI_INPUT);
                const TAG = tyronzil_1.TransitionTag.Create;
                if (OPERATION !== undefined) {
                    console.log(log_colors_1.default.brightGreen(`Your ${TAG} request  got processed!`));
                }
                else {
                    throw new ErrorCode_1.default("RequestUnsuccessful", "Wrong choice. Try again.");
                }
                return {
                    init: init,
                    operation: OPERATION,
                    tag: TAG
                };
            }))
                .then((didCreate) => __awaiter(this, void 0, void 0, function* () {
                console.log(log_colors_1.default.brightGreen(`Let's deploy the user's Tyron DID smart contract!`));
                const version = readline.question(log_colors_1.default.green(`What version of the DIDC would you like to deploy?`) + ` - Versions currently supported: [2.0] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                // The user deploys their DIDC and calls the TyronInit transition
                const DEPLOYED_CONTRACT = yield tyronzil_1.default.deploy(didCreate.init, version);
                const DIDC_ADDR = DEPLOYED_CONTRACT.contract.address;
                const DID = yield did_scheme_1.default.newDID({ network: NETWORK, didUniqueSuffix: DIDC_ADDR });
                console.log(log_colors_1.default.green(`The user's Tyron Decentralized Identifier is: `) + log_colors_1.default.green(DID.did));
                const PARAMS = yield tyronzil_1.default.create("pungtas", didCreate.operation.document, didCreate.operation.updateKey, didCreate.operation.recoveryKey);
                yield tyronzil_1.default.submit(didCreate.init, DIDC_ADDR, didCreate.tag, PARAMS, ".did");
                // Sets the DIDC's domain name
                const domainName = readline.question(log_colors_1.default.green(`What domain name avatar.did would you like to register for your DIDC?`) + ` - [e.g.: julio.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const DOT_INDEX = domainName.lastIndexOf(".");
                const SSI_DOMAIN = domainName.substring(DOT_INDEX);
                if (SSI_DOMAIN !== ".did") {
                    throw new ErrorCode_1.default("CodeNotDidDomain", "The DIDC MUST first get registered on a .did domain");
                }
                const AVATAR = domainName.substring(0, DOT_INDEX);
                yield resolver_1.default.validateAvatar(AVATAR);
                const DNS_PARAMS = yield tyronzil_1.default.dns(".did", AVATAR);
                yield tyronzil_1.default.submit(didCreate.init, DIDC_ADDR, tyronzil_1.TransitionTag.Dns, DNS_PARAMS, ".did");
                return {
                    did: DID.did,
                    operation: didCreate.operation
                };
            }))
                .then((create) => __awaiter(this, void 0, void 0, function* () {
                // To save the private keys:
                yield util_1.default.savePrivateKeys(create.did, create.operation.privateKeys);
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
    /***            ****            ****/
    /** Updates the DIDC's domain names */
    static handleDns() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const SET_NETWORK = this.network();
                const input = readline.question(log_colors_1.default.green(`To fetch the user's DIDC, give the address of the their DID smart contract (1) OR their domain.did (2)`) + ` - [1/2] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                let DIDC_ADDR;
                switch (input) {
                    case "1":
                        DIDC_ADDR = readline.question(log_colors_1.default.green(`Provide the DIDC's hex-encoded address`) + log_colors_1.default.lightBlue(`Your answer: `));
                        break;
                    case "2":
                        const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: uriel.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                        DIDC_ADDR = yield resolver_1.default.resolveDns(SET_NETWORK.network, SET_NETWORK.initTyron, domainName);
                        break;
                    default:
                        throw new ErrorCode_2.default("You have to choose between the previous options");
                }
                ;
                const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                console.log(log_colors_1.default.brightGreen(`Initializing...`));
                yield tyronzil_1.default.initialize(SET_NETWORK.network, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit)
                    .then((init) => __awaiter(this, void 0, void 0, function* () {
                    const domainName = readline.question(log_colors_1.default.green(`What domain name avatar.did would you like to register for your DIDC?`) + ` - [e.g.: iva.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                    const DOT_INDEX = domainName.lastIndexOf(".");
                    const SSI_DOMAIN = domainName.substring(DOT_INDEX);
                    if (SSI_DOMAIN !== ".did") {
                        throw new ErrorCode_1.default("CodeNotDidDomain", "The DIDC MUST get registered on a .did domain");
                    }
                    const AVATAR = domainName.substring(0, DOT_INDEX);
                    yield resolver_1.default.validateAvatar(AVATAR);
                    const DNS_PARAMS = yield tyronzil_1.default.dns(".did", AVATAR);
                    yield tyronzil_1.default.submit(init, DIDC_ADDR, tyronzil_1.TransitionTag.Dns, DNS_PARAMS, ".did");
                }))
                    .catch(err => { throw err; });
            }
            catch (err) {
                console.error(log_colors_1.default.red(err));
            }
        });
    }
    /***            ****            ****/
    /** Resolves the Tyron DID and saves it */
    static handleResolve() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const SET_NETWORK = this.network();
                /** Asks for the user's domain name to fetch their DIDC */
                const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: uriel.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const DIDC_ADDR = yield resolver_1.default.resolveDns(SET_NETWORK.network, SET_NETWORK.initTyron, domainName);
                /** Whether to resolve the DID as a document or resolution result */
                const RESOLUTION_CHOICE = readline.question(log_colors_1.default.green(`Would you like to resolve your DID as a document(1) or as a resolution result(2)? `) + `- [1/2] - Defaults to document - ` + log_colors_1.default.lightBlue(`Your answer: `));
                let ACCEPT;
                switch (RESOLUTION_CHOICE) {
                    case "1":
                        ACCEPT = did_document_1.Accept.contentType;
                        break;
                    case "2":
                        ACCEPT = did_document_1.Accept.Result;
                        break;
                    default:
                        ACCEPT = did_document_1.Accept.contentType;
                        break;
                }
                const RESOLUTION_INPUT = {
                    didcAddr: DIDC_ADDR,
                    metadata: {
                        accept: ACCEPT
                    }
                };
                console.log(log_colors_1.default.brightGreen(`Resolving your request...`));
                /** Resolves the Tyron DID */
                yield did_document_1.default.resolution(SET_NETWORK.network, RESOLUTION_INPUT)
                    .then((did_resolved) => __awaiter(this, void 0, void 0, function* () {
                    // Saves the DID-Document
                    const DID = did_resolved.id;
                    yield did_document_1.default.write(DID, did_resolved);
                }))
                    .catch(err => { throw err; });
            }
            catch (err) {
                console.error(log_colors_1.default.red(err));
            }
        });
    }
    /***            ****            ****/
    /** Handles the `Tyron DID-Recover` operation */
    static handleRecover() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(log_colors_1.default.brightGreen(`To recover your Tyron DID, let's fetch its current DIDC-State from the Zilliqa blockchain platform!`));
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            /** Asks for the user's domain name to fetch their DIDC */
            const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: uriel.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, domainName);
            yield did_state_1.default.fetch(NETWORK, DIDC_ADDR)
                .then((did_state) => __awaiter(this, void 0, void 0, function* () {
                const RECOVERY_PRIVATE_KEY = readline.question(log_colors_1.default.brightGreen(`DID-State retrieved!`) + log_colors_1.default.green(` - Provide the recovery private key - `) + log_colors_1.default.lightBlue(`Your answer: `));
                yield util_1.default.verifyKey(RECOVERY_PRIVATE_KEY, did_state.did_recovery_key);
                // Adds verification-method inputs & services:
                const KEY_INPUT = yield util_1.default.InputKeys();
                const SERVICES = yield util_1.default.services();
                const CLI_INPUT = {
                    network: NETWORK,
                    publicKeyInput: KEY_INPUT,
                    services: SERVICES
                };
                const RECOVER_INPUT = {
                    did: did_state.decentralized_identifier,
                    recoveryPrivateKey: RECOVERY_PRIVATE_KEY,
                    cliInput: CLI_INPUT
                };
                const OPERATION = yield did_recover_1.default.execute(RECOVER_INPUT);
                const TAG = tyronzil_1.TransitionTag.Recover;
                if (OPERATION !== undefined) {
                    console.log(log_colors_1.default.brightGreen(`Your ${TAG} request  got processed!`));
                }
                else {
                    throw new ErrorCode_1.default("RequestUnsuccessful", "Wrong choice. Try again.");
                }
                return {
                    state: did_state,
                    operation: OPERATION,
                    tag: TAG
                };
            }))
                .then((didRecover) => __awaiter(this, void 0, void 0, function* () {
                console.log(log_colors_1.default.brightGreen(`Next, let's save the DID-Recover operation on the Zilliqa blockchain platform, so it stays immutable!`));
                const PARAMS = yield tyronzil_1.default.recover('pungtas', didRecover.operation.newDocument, didRecover.operation.docHash, didRecover.operation.signature, didRecover.operation.newUpdateKey, didRecover.operation.newRecoveryKey);
                const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const INITIALIZED = yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit);
                yield tyronzil_1.default.submit(INITIALIZED, DIDC_ADDR, didRecover.tag, PARAMS, ".did");
                return didRecover;
            }))
                .then((didRecover) => __awaiter(this, void 0, void 0, function* () {
                // To save the private keys:
                yield util_1.default.savePrivateKeys(didRecover.operation.decentralized_identifier, didRecover.operation.privateKeys);
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
    /***            ****            ****/
    /** Handles the `Tyron DID-Update` operation */
    static handleUpdate() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(log_colors_1.default.brightGreen(`To update your Tyron DID, let's fetch its current DIDC state from the Zilliqa blockchain platform!`));
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            /** Asks for the user's domain name to fetch their DIDC */
            const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: julio.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, domainName);
            yield did_state_1.default.fetch(NETWORK, DIDC_ADDR)
                .then((did_state) => __awaiter(this, void 0, void 0, function* () {
                const UPDATE_PRIVATE_KEY = readline.question(log_colors_1.default.brightGreen(`DID-State retrieved!`) + log_colors_1.default.green(` - Provide the update private key - `) + log_colors_1.default.lightBlue(`Your answer: `));
                yield util_1.default.verifyKey(UPDATE_PRIVATE_KEY, did_state.did_update_key);
                const patches_amount = readline.question(log_colors_1.default.green(`How many patches would you like to make? - `) + log_colors_1.default.lightBlue(`Your answer: `));
                const PATCHES = [];
                for (let i = 0, t = Number(patches_amount); i < t; ++i) {
                    // Asks for the specific patch action to update the DID:
                    const action = readline.question(log_colors_1.default.green(`You may choose one of the following actions to update the DID:
                'add-keys'(1) - if the key id already exists, then its value will get updated;
                'remove-keys'(2);
                'add-services'(3) - if the service id already exists, then its value will get updated;
                'remove-services'(4)`)
                        + ` - [1/2/3/4] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                    let KEY_INPUT;
                    let SERVICES;
                    const ID = [];
                    let PATCH_ACTION;
                    switch (action) {
                        case '1':
                            PATCH_ACTION = document_model_1.PatchAction.AddKeys;
                            KEY_INPUT = yield util_1.default.InputKeys();
                            break;
                        case '2':
                            PATCH_ACTION = document_model_1.PatchAction.RemoveKeys;
                            const amount = readline.question(log_colors_1.default.green(`How many keys would you like to remove? - `) + log_colors_1.default.lightBlue(`Your answer: `));
                            for (let i = 0, t = Number(amount); i < t; ++i) {
                                const KEY_ID = readline.question(log_colors_1.default.green(`Next, provide the ID of the key that you would like to remove - `) + log_colors_1.default.lightBlue(`Your answer: `));
                                ID.push(KEY_ID);
                            }
                            break;
                        case '3':
                            PATCH_ACTION = document_model_1.PatchAction.AddServices;
                            SERVICES = yield util_1.default.services();
                            break;
                        case '4':
                            PATCH_ACTION = document_model_1.PatchAction.RemoveServices;
                            {
                                const amount = readline.question(log_colors_1.default.green(`How many services would you like to remove? - `) + log_colors_1.default.lightBlue(`Your answer: `));
                                for (let i = 0, t = Number(amount); i < t; ++i) {
                                    const SERVICE_ID = readline.question(log_colors_1.default.green(`Next, provide the ID of the service that you would like to remove - `) + log_colors_1.default.lightBlue(`Your answer: `));
                                    ID.push(SERVICE_ID);
                                }
                            }
                            break;
                        default:
                            throw new ErrorCode_1.default("CodeIncorrectPatchAction", "The chosen action is not valid");
                    }
                    const PATCH = {
                        action: PATCH_ACTION,
                        keyInput: KEY_INPUT,
                        services: SERVICES,
                        ids: ID
                    };
                    PATCHES.push(PATCH);
                }
                const UPDATE_INPUT = {
                    state: did_state,
                    updatePrivateKey: UPDATE_PRIVATE_KEY,
                    patches: PATCHES
                };
                const OPERATION = yield did_update_1.default.execute(UPDATE_INPUT);
                const TAG = tyronzil_1.TransitionTag.Update;
                if (OPERATION !== undefined) {
                    console.log(log_colors_1.default.brightGreen(`The ${TAG} request  got processed!`));
                }
                else {
                    throw new ErrorCode_1.default("RequestUnsuccessful", "Wrong choice. Try again.");
                }
                return {
                    state: did_state,
                    operation: OPERATION,
                    tag: TAG
                };
            }))
                .then((didUpdate) => __awaiter(this, void 0, void 0, function* () {
                console.log(log_colors_1.default.brightGreen(`Next, let's save the DID-Update operation on the Zilliqa blockchain platform, so it stays immutable!`));
                const PARAMS = yield tyronzil_1.default.update("pungtas", didUpdate.operation.newDocument, didUpdate.operation.docHash, didUpdate.operation.signature, didUpdate.operation.newUpdateKey);
                const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const INITIALIZED = yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit);
                yield tyronzil_1.default.submit(INITIALIZED, DIDC_ADDR, didUpdate.tag, PARAMS, ".did");
                return didUpdate;
            }))
                .then((didUpdate) => __awaiter(this, void 0, void 0, function* () {
                // To save the private keys:
                yield util_1.default.savePrivateKeys(didUpdate.operation.decentralized_identifier, didUpdate.operation.privateKeys);
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
    /***            ****            ***/
    /** Handles the `Tyron DID-Deactivate` operation */
    static handleDeactivate() {
        return __awaiter(this, void 0, void 0, function* () {
            console.log(log_colors_1.default.brightGreen(`To deactivate the Tyron DID, let's fetch its current DIDC state from the Zilliqa blockchain platform!`));
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            /** Asks for the user's domain name to fetch their DIDC */
            const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: julio.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, domainName);
            yield did_state_1.default.fetch(NETWORK, DIDC_ADDR)
                .then((did_state) => __awaiter(this, void 0, void 0, function* () {
                const RECOVERY_PRIVATE_KEY = readline.question(log_colors_1.default.brightGreen(`DID-State retrieved!`) + log_colors_1.default.green(` - Provide the recovery private key - `) + log_colors_1.default.lightBlue(`Your answer: `));
                yield util_1.default.verifyKey(RECOVERY_PRIVATE_KEY, did_state.did_recovery_key);
                return {
                    did_state: did_state,
                    recoveryPrivateKey: RECOVERY_PRIVATE_KEY
                };
            }))
                .then((request) => __awaiter(this, void 0, void 0, function* () {
                const DEACTIVATE_INPUT = {
                    state: request.did_state,
                    recoveryPrivateKey: request.recoveryPrivateKey
                };
                const OPERATION = yield did_deactivate_1.default.execute(DEACTIVATE_INPUT);
                const TAG = tyronzil_1.TransitionTag.Deactivate;
                if (OPERATION !== undefined) {
                    console.log(log_colors_1.default.brightGreen(`Your ${TAG} request  got processed!`));
                }
                else {
                    throw new ErrorCode_1.default("RequestUnsuccessful", "Wrong choice. Try again.");
                }
                return {
                    request: request,
                    operation: OPERATION,
                    tag: TAG
                };
            }))
                .then((didDeactivate) => __awaiter(this, void 0, void 0, function* () {
                console.log(log_colors_1.default.brightGreen(`Next, let's save your DID-Deactivate operation on the Zilliqa blockchain platform, so it stays immutable!`));
                const PARAMS = yield tyronzil_1.default.deactivate("pungtas", didDeactivate.operation.signature);
                const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
                const INITIALIZED = yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit);
                yield tyronzil_1.default.submit(INITIALIZED, DIDC_ADDR, didDeactivate.tag, PARAMS, ".did");
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
    /** Initializes the SSI Token in the user's DIDC */
    static handleSsiToken() {
        return __awaiter(this, void 0, void 0, function* () {
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            /** Asks for the user's domain name to fetch their DIDC */
            const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: julio.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, domainName);
            const token = readline.question(log_colors_1.default.green(`What is the SSI Token that you would like to register into your DIDC? `) + `- [e.g.: xsgd] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit).then((init) => __awaiter(this, void 0, void 0, function* () {
                const PARAMS = yield tyronzil_1.default.ssiToken(token);
                yield tyronzil_1.default.submit(init, DIDC_ADDR, tyronzil_1.TransitionTag.SsiToken, PARAMS, ".did");
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
    /** Initializes the donation campaign code in the user's DIDC */
    static handleDonation() {
        return __awaiter(this, void 0, void 0, function* () {
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            /** Asks for the user's domain name to fetch their DIDC */
            const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name (to fetch their DID smart contract)? `) + `- [e.g.: julio.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, domainName);
            const campaign = readline.question(log_colors_1.default.green(`What is the donation campaign code that you would like to register into your DIDC? `) + `- [e.g.: covid-aid] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit).then((init) => __awaiter(this, void 0, void 0, function* () {
                const PARAMS = yield tyronzil_1.default.donate(campaign);
                yield tyronzil_1.default.submit(init, DIDC_ADDR, tyronzil_1.TransitionTag.Donate, PARAMS, ".did");
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
    /** Donates $XSGD */
    static handleDonate() {
        return __awaiter(this, void 0, void 0, function* () {
            const SET_NETWORK = this.network();
            const NETWORK = SET_NETWORK.network;
            /** Asks for the user's domain name to fetch their DIDC */
            const domainName = readline.question(log_colors_1.default.green(`What is the user's domain name? `) + `- [e.g.: julio.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const campaign = readline.question(log_colors_1.default.green(`What is the donation campaign code? `) + `- [e.g.: covid-aid] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const contractOwner_privateKey = readline.question(log_colors_1.default.green(`What is the user's private key (contract owner key)?`) + ` - [Hex-encoded private key] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const toDomainName = readline.question(log_colors_1.default.green(`What is the user's domain name that you would like to donate $XSGD? `) + `- [e.g.: mar.did] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            const amount = readline.question(log_colors_1.default.green(`How many $XSGD would you like to donate? - `) + log_colors_1.default.lightBlue(`Your answer: `));
            const xsgdPrivateKey = readline.question(log_colors_1.default.green(`What is your $XSGD private key? - `) + log_colors_1.default.lightBlue(`Your answer: `));
            const gas_limit = readline.question(log_colors_1.default.green(`What is the gas limit?`) + ` - [Recommended value: 5,000] - ` + log_colors_1.default.lightBlue(`Your answer: `));
            yield tyronzil_1.default.initialize(NETWORK, SET_NETWORK.initTyron, contractOwner_privateKey, gas_limit).then((init) => __awaiter(this, void 0, void 0, function* () {
                const DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, domainName);
                const TO_DIDC_ADDR = yield resolver_1.default.resolveDns(NETWORK, SET_NETWORK.initTyron, toDomainName);
                const xsgd_privateKey = zcrypto.normalizePrivateKey(xsgdPrivateKey);
                const xsgd_publicKey = zcrypto.getPubKeyFromPrivateKey(xsgd_privateKey);
                const to_addr = zcrypto.fromBech32Address(TO_DIDC_ADDR).substring(2);
                const SIGNATURE = "0x" + zcrypto.sign(Buffer.from(to_addr, 'hex'), xsgd_privateKey, xsgd_publicKey);
                const PARAMS = yield tyronzil_1.default.xTransfer(campaign, "xsgd", "pungtas", zcrypto.fromBech32Address(TO_DIDC_ADDR), String(Number(amount) * 1e6), SIGNATURE);
                yield tyronzil_1.default.submit(init, DIDC_ADDR, tyronzil_1.TransitionTag.XTranfer, PARAMS, ".did");
            }))
                .catch(err => console.error(log_colors_1.default.red(err)));
        });
    }
}
exports.default = TyronCLI;
//# sourceMappingURL=tyronZIL-CLI.js.map