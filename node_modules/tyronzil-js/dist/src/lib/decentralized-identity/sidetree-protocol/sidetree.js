"use strict";
/*
    TyronZIL-js: Decentralized identity client for the Zilliqa blockchain platform
    Copyright (C) 2020 Julio Cesar Cabrapan Duarte

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sidetree = exports.OperationType = void 0;
const log_colors_1 = __importDefault(require("../../../bin/log-colors"));
const document_model_1 = require("./models/document-model");
const did_keys_1 = require("../util/did-keys");
const ErrorCode_1 = __importDefault(require("../util/ErrorCode"));
/** Operation types */
var OperationType;
(function (OperationType) {
    OperationType["Create"] = "Created";
    OperationType["Recover"] = "Recovered";
    OperationType["Update"] = "Updated";
    OperationType["Deactivate"] = "Deactivated";
})(OperationType = exports.OperationType || (exports.OperationType = {}));
class Sidetree {
    static documentModel(encoded) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const STRING = Buffer.from(encoded, 'hex').toString();
                const DOC = JSON.parse(STRING);
                console.log(log_colors_1.default.brightGreen("The DID-Document (Sidetree-Document-Model format):"));
                console.log(JSON.stringify(DOC, null, 2));
                const DOCUMENT = {
                    public_keys: DOC.public_keys
                };
                if (DOC.service_endpoints !== undefined && DOC.service_endpoints.length !== 0) {
                    DOCUMENT.service_endpoints = DOC.service_endpoints;
                }
                return DOCUMENT;
            }
            catch (err) {
                throw err;
            }
        });
    }
    static processPatches(patches, doc) {
        return __awaiter(this, void 0, void 0, function* () {
            let PUBLIC_KEYS = doc.public_keys;
            const KEY_ID_SET = new Set();
            for (const key of PUBLIC_KEYS) {
                // IDs must be unique
                if (!KEY_ID_SET.has(key.id)) {
                    KEY_ID_SET.add(key.id);
                }
                else {
                    throw new ErrorCode_1.default("KeyDuplicated", "The key ID must be unique");
                }
            }
            let SERVICES = doc.service_endpoints;
            const SERVICE_ID_SET = new Set();
            if (SERVICES === undefined) {
                SERVICES = [];
            }
            else if (SERVICES.length > 0) {
                for (const service of SERVICES) {
                    // IDs must be unique
                    if (!SERVICE_ID_SET.has(service.id)) {
                        SERVICE_ID_SET.add(service.id);
                    }
                    else {
                        throw new ErrorCode_1.default("ServiceDuplicated", "There are services with the same ID");
                    }
                }
            }
            const PATCHES = [];
            const PRIVATE_KEYS = [];
            for (const patch of patches) {
                switch (patch.action) {
                    case document_model_1.PatchAction.AddKeys:
                        if (patch.keyInput !== undefined) {
                            yield this.addKeys(patch.keyInput, KEY_ID_SET)
                                .then(new_keys => {
                                PATCHES.push(new_keys.patch);
                                for (const key of new_keys.publicKey) {
                                    PUBLIC_KEYS.push(key);
                                }
                                for (const key of new_keys.privateKey) {
                                    PRIVATE_KEYS.push(key);
                                }
                            })
                                .catch(err => { throw err; });
                        }
                        else {
                            throw new ErrorCode_1.default("Missing", "No key in AddKeys patch");
                        }
                        break;
                    case document_model_1.PatchAction.RemoveKeys:
                        if (patch.public_keys !== undefined) {
                            const ID = patch.public_keys;
                            const key_ids = [];
                            for (const id of ID) {
                                if (typeof id === 'string' && KEY_ID_SET.has(id)) {
                                    key_ids.push(id);
                                    KEY_ID_SET.delete(id);
                                }
                                else {
                                    throw new ErrorCode_1.default("NotFound", "The key ID does not exist");
                                }
                            }
                            const IDs = new Set(key_ids);
                            PUBLIC_KEYS = PUBLIC_KEYS.filter(key => !IDs.has(key.id));
                            if (PUBLIC_KEYS.length === 0) {
                                throw new ErrorCode_1.default("Insufficient", "The DID-Document must have at least one public key");
                            }
                            PATCHES.push({
                                action: document_model_1.PatchAction.RemoveKeys,
                                public_keys: key_ids
                            });
                        }
                        break;
                    case document_model_1.PatchAction.AddServices:
                        if (patch.service_endpoints !== undefined) {
                            const NEW_SERVICES = [];
                            for (const service of patch.service_endpoints) {
                                if (!SERVICE_ID_SET.has(service.id)) {
                                    SERVICES.push(service);
                                    NEW_SERVICES.push(service);
                                }
                                else {
                                    throw new ErrorCode_1.default("ServiceDuplicated", "There are services with the same ID");
                                }
                            }
                            PATCHES.push({
                                action: document_model_1.PatchAction.AddServices,
                                service_endpoints: NEW_SERVICES
                            });
                        }
                        else {
                            throw new ErrorCode_1.default("Missing", "No services given to add");
                        }
                        break;
                    case document_model_1.PatchAction.RemoveServices:
                        if (patch.ids !== undefined) {
                            const ID = [];
                            for (const id of patch.ids) {
                                if (!SERVICE_ID_SET.has(id)) {
                                    throw new ErrorCode_1.default("NotFound", `The service ID you want to remove does not exist`);
                                }
                                else {
                                    ID.push(id);
                                    SERVICE_ID_SET.delete(id);
                                }
                            }
                            PATCHES.push({
                                action: document_model_1.PatchAction.RemoveServices,
                                ids: ID
                            });
                            // Removing the services from the DID-Doc
                            const IDs = new Set(ID);
                            SERVICES = SERVICES.filter(service => !IDs.has(service.id));
                        }
                        else {
                            throw new ErrorCode_1.default("Missing", "No service ID given to remove");
                        }
                        break;
                    default:
                        throw new ErrorCode_1.default("CodeIncorrectPatchAction", "The chosen action is not valid");
                }
            }
            return {
                patches: PATCHES,
                doc: {
                    public_keys: PUBLIC_KEYS,
                    service_endpoints: SERVICES
                },
                privateKey: PRIVATE_KEYS,
            };
        });
    }
    static addKeys(input, idSet) {
        return __awaiter(this, void 0, void 0, function* () {
            const PUBLIC_KEYS = [];
            const PRIVATE_KEYS = [];
            for (let i = 0, t = input.length; i < t; ++i) {
                const KEY_INPUT = input[i];
                /** To create the DID public key */
                const KEY_PAIR_INPUT = {
                    id: KEY_INPUT.id,
                    purpose: KEY_INPUT.purpose
                };
                if (idSet.has(KEY_INPUT.id)) {
                    throw new ErrorCode_1.default("KeyDuplicated", "The key ID must be unique");
                }
                // Creates the DID key-pair:
                const [PUBLIC_KEY, PRIVATE_KEY] = yield did_keys_1.Cryptography.operationKeyPair(KEY_PAIR_INPUT);
                PUBLIC_KEYS.push(PUBLIC_KEY);
                PRIVATE_KEYS.push(PRIVATE_KEY);
            }
            const PATCH = {
                action: document_model_1.PatchAction.AddKeys,
                public_keys: PUBLIC_KEYS
            };
            const NEW_KEYS = {
                patch: PATCH,
                publicKey: PUBLIC_KEYS,
                privateKey: PRIVATE_KEYS
            };
            return NEW_KEYS;
        });
    }
}
exports.Sidetree = Sidetree;
//# sourceMappingURL=sidetree.js.map