"use strict";
/*
    TyronZIL-js: Decentralized identity client for the Zilliqa blockchain platform
    Copyright (C) 2020 Julio Cesar Cabrapan Duarte

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Sidetree = exports.OperationType = void 0;
const document_model_1 = require("./models/document-model");
const did_keys_1 = require("../util/did-keys");
const ErrorCode_1 = __importDefault(require("../util/ErrorCode"));
const tyronzil_1 = __importDefault(require("../../blockchain/tyronzil"));
/** Operation types */
var OperationType;
(function (OperationType) {
    OperationType["Create"] = "Created";
    OperationType["Recover"] = "Recovered";
    OperationType["Update"] = "Updated";
    OperationType["Deactivate"] = "Deactivated";
})(OperationType = exports.OperationType || (exports.OperationType = {}));
class Sidetree {
    static processPatches(patches) {
        return __awaiter(this, void 0, void 0, function* () {
            let UPDATE_DOCUMENT = [];
            let PRIVATE_KEYS = [];
            for (const patch of patches) {
                switch (patch.action) {
                    case document_model_1.PatchAction.AddKeys:
                        if (patch.keyInput !== undefined) {
                            yield this.addKeys(patch.keyInput)
                                .then((new_keys) => __awaiter(this, void 0, void 0, function* () {
                                for (let key of new_keys.publicKeys) {
                                    UPDATE_DOCUMENT.push(key);
                                    PRIVATE_KEYS.push();
                                }
                                for (let key of new_keys.privateKeys) {
                                    PRIVATE_KEYS.push(key);
                                }
                            }))
                                .catch(err => { throw err; });
                        }
                        else {
                            throw new ErrorCode_1.default("Missing", "No key in AddKeys patch");
                        }
                        break;
                    case document_model_1.PatchAction.RemoveKeys:
                        if (patch.ids !== undefined) {
                            for (const id of patch.ids) {
                                const KEY = {
                                    id: id
                                };
                                const DOC_ELEMENT = yield tyronzil_1.default.documentElement(document_model_1.DocumentElement.VerificationMethod, document_model_1.Action.Removing, KEY);
                                UPDATE_DOCUMENT.push(DOC_ELEMENT);
                            }
                        }
                        break;
                    case document_model_1.PatchAction.AddServices:
                        if (patch.services !== undefined) {
                            for (let service of patch.services) {
                                UPDATE_DOCUMENT.push(service);
                            }
                        }
                        else {
                            throw new ErrorCode_1.default("Missing", "No services given to add");
                        }
                        break;
                    case document_model_1.PatchAction.RemoveServices:
                        if (patch.ids !== undefined) {
                            for (const id of patch.ids) {
                                const SERVICE = {
                                    id: id,
                                    type: "",
                                    transferProtocol: document_model_1.DataTransferProtocol.Https,
                                    uri: ""
                                };
                                const DOC_ELEMENT = yield tyronzil_1.default.documentElement(document_model_1.DocumentElement.Service, document_model_1.Action.Removing, undefined, SERVICE);
                                UPDATE_DOCUMENT.push(DOC_ELEMENT);
                            }
                        }
                        else {
                            throw new ErrorCode_1.default("Missing", "No service ID given to remove");
                        }
                        break;
                    default:
                        throw new ErrorCode_1.default("CodeIncorrectPatchAction", "The chosen action is not valid");
                }
            }
            return {
                updateDocument: UPDATE_DOCUMENT,
                privateKeys: PRIVATE_KEYS,
            };
        });
    }
    static addKeys(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const VERIFICATION_METHODS = [];
            const PRIVATE_KEYS = [];
            for (let i = 0, t = input.length; i < t; ++i) {
                const KEY_INPUT = input[i];
                /** To create the DID public key */
                const KEY_PAIR_INPUT = {
                    id: KEY_INPUT.id
                };
                // Creates the key pair:
                const [VERIFICATION_METHOD, PRIVATE_KEY] = yield did_keys_1.Cryptography.operationKeyPair(KEY_PAIR_INPUT);
                VERIFICATION_METHODS.push(VERIFICATION_METHOD);
                PRIVATE_KEYS.push(PRIVATE_KEY);
            }
            const NEW_KEYS = {
                publicKeys: VERIFICATION_METHODS,
                privateKeys: PRIVATE_KEYS
            };
            return NEW_KEYS;
        });
    }
}
exports.Sidetree = Sidetree;
//# sourceMappingURL=sidetree.js.map