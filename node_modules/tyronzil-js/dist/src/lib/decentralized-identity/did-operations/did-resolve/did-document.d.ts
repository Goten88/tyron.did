import { DidServiceEndpointModel } from '../../protocols/models/document-model';
import { VerificationMethodModel } from '../../protocols/models/verification-method-models';
import { NetworkNamespace } from '../../tyronZIL-schemes/did-scheme';
import DidState from './did-state';
export declare enum Accept {
    contentType = "application/did+json",
    Result = "application/did+json;profile='https://w3c-ccg.github.io/did-resolution'"
}
/** Generates a `Tyron DID-Document` */
export default class DidDoc {
    readonly id: string;
    readonly publicKey?: VerificationMethodModel;
    readonly authentication?: VerificationMethodModel;
    readonly assertionMethod?: VerificationMethodModel;
    readonly keyAgreement?: VerificationMethodModel;
    readonly capabilityInvocation?: VerificationMethodModel;
    readonly capabilityDelegation?: VerificationMethodModel;
    readonly xsgdKey?: VerificationMethodModel;
    readonly service?: DidServiceEndpointModel[];
    private constructor();
    /***            ****            ***/
    /** The `Tyron DID-Resolution` method */
    static resolution(network: NetworkNamespace, input: ResolutionInput): Promise<DidDoc | ResolutionResult>;
    /***            ****            ***/
    /** Generates a 'Tyron DID-Read' operation, resolving any `Tyron DID-state` into its DID-Document */
    static read(state: DidState): Promise<DidDoc>;
    /***            ****            ***/
    /** Saves the `Tyron DID-Document` */
    static write(did: string, input: DidDoc | ResolutionResult): Promise<void>;
}
export interface ResolutionInput {
    didcAddr: string;
    metadata: ResolutionInputMetadata;
}
export interface ResolutionInputMetadata {
    accept: Accept;
    versionId?: string;
    versionTime?: string;
    noCache?: boolean;
    dereferencingInput?: DereferencingInputMetadata;
}
interface DereferencingInputMetadata {
    serviceType?: string;
    followRedirect?: boolean;
}
export interface ResolutionResult {
    id: string;
    resolutionMetadata: unknown;
    document: DidDoc;
    metadata: DocumentMetadata;
}
interface DocumentMetadata {
    contentType: string;
    updateKey: string;
    recoveryKey: string;
}
export {};
