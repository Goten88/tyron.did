"use strict";
/*
    tyronzil-sdk: Tyron DID SDK - Zilliqa's DID-Method at www.tyronZIL.com
    Copyright (C) 2020 Julio Cesar Cabrapan Duarte

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
*/
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Cryptography = void 0;
const zcrypto = __importStar(require("@zilliqa-js/crypto"));
const tyronzil_1 = __importDefault(require("../../blockchain/tyronzil"));
const document_model_1 = require("../protocols/models/document-model");
const verification_method_models_1 = require("../protocols/models/verification-method-models");
const ErrorCode_1 = __importDefault(require("./ErrorCode"));
/** Generates cryptographic operations */
class Cryptography {
    /** Asymmetric cryptography to generate the key pair using the KEY_ALGORITHM (secp256k1)
     * @returns [publicKey, privateKey] */
    static operationKeyPair(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const PRIVATE_KEY = zcrypto.schnorr.generatePrivateKey();
            const PUBLIC_KEY = "0x" + zcrypto.getPubKeyFromPrivateKey(PRIVATE_KEY);
            const VERIFICATION_METHOD = {
                id: input.id,
                key: PUBLIC_KEY
            };
            const DOC_ELEMENT = yield tyronzil_1.default.documentElement(document_model_1.DocumentElement.VerificationMethod, document_model_1.Action.Adding, VERIFICATION_METHOD);
            const PRIVATE_KEY_MODEL = {
                id: input.id,
                key: PRIVATE_KEY
            };
            return [DOC_ELEMENT, PRIVATE_KEY_MODEL];
        });
    }
    /** Generates a secp256k1 key pair
     * @returns [publicKey, privateKey] */
    static keyPair(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const PRIVATE_KEY = zcrypto.schnorr.generatePrivateKey();
            const PUBLIC_KEY = zcrypto.getPubKeyFromPrivateKey(PRIVATE_KEY);
            const PRIVATE_KEY_MODEL = {
                id: id,
                key: PRIVATE_KEY
            };
            return [PUBLIC_KEY, PRIVATE_KEY_MODEL];
        });
    }
    static processKeys(input) {
        return __awaiter(this, void 0, void 0, function* () {
            const KEY_ID_SET = new Set();
            let KEYS = {};
            let NEW_KEY;
            for (const key of input) {
                // IDs must be unique
                if (!KEY_ID_SET.has(key.id)) {
                    KEY_ID_SET.add(key.id);
                }
                else {
                    throw new ErrorCode_1.default("KeyDuplicated", "The key ID must be unique");
                }
                switch (key.id) {
                    case verification_method_models_1.PublicKeyPurpose.General:
                        NEW_KEY = {
                            general: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case verification_method_models_1.PublicKeyPurpose.Auth:
                        NEW_KEY = {
                            authentication: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case verification_method_models_1.PublicKeyPurpose.Assertion:
                        NEW_KEY = {
                            assertion: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case verification_method_models_1.PublicKeyPurpose.Agreement:
                        NEW_KEY = {
                            agreement: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case verification_method_models_1.PublicKeyPurpose.Invocation:
                        NEW_KEY = {
                            invocation: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case verification_method_models_1.PublicKeyPurpose.Delegation:
                        NEW_KEY = {
                            delegation: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case verification_method_models_1.PublicKeyPurpose.XSGD:
                        NEW_KEY = {
                            xsgd: "0x" + key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case "update":
                        NEW_KEY = {
                            did_update: key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    case "recovery":
                        NEW_KEY = {
                            did_recovery: key.key
                        };
                        Object.assign(KEYS, NEW_KEY);
                        break;
                    default:
                        throw new ErrorCode_1.default("InvalidID", `The client detected an invalid key ID`);
                }
            }
            return KEYS;
        });
    }
}
exports.Cryptography = Cryptography;
//# sourceMappingURL=did-keys.js.map